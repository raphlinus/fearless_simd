// Copyright 2025 the Fearless_SIMD Authors
// SPDX-License-Identifier: Apache-2.0 OR MIT

use std::{fs::File, io::Write, path::Path};

use clap::{Parser, ValueEnum};
use proc_macro2::TokenStream;

mod arch;
mod generic;
mod mk_neon;
mod mk_ops;
mod mk_simd_trait;
mod mk_simd_types;
mod ops;
mod types;
mod mk_fallback;

#[derive(Clone, Copy, ValueEnum, Debug)]
enum Module {
    SimdTypes,
    SimdTrait,
    Ops,
    Neon,
    Fallback
}

#[derive(Parser)]
struct Cli {
    #[arg(short, long)]
    module: Option<Module>,
}

impl Module {
    fn generate_code(self) -> TokenStream {
        match self {
            Module::SimdTypes => mk_simd_types::mk_simd_types(),
            Module::SimdTrait => mk_simd_trait::mk_simd_trait(),
            Module::Ops => mk_ops::mk_ops(),
            Module::Neon => mk_neon::mk_neon_impl(mk_neon::Level::Neon),
            Module::Fallback => mk_fallback::mk_fallback_impl()
        }
    }

    fn generate_string(self) -> String {
        let code = self.generate_code();
        let parsed = syn::parse_file(&code.to_string()).expect("error parsing {name}");
        let code_str = prettyplease::unparse(&parsed);
        format!("// This file is autogenerated by fearless_simd_gen\n\n{code_str}")
    }

    fn file_base(self) -> &'static str {
        match self {
            Module::SimdTypes => "simd_types",
            Module::SimdTrait => "simd_trait",
            Module::Ops => "ops",
            Module::Neon => "neon",
            Module::Fallback => "fallback"
        }
    }
}

const MODULES: &[Module] = &[
    Module::SimdTypes,
    Module::SimdTrait,
    Module::Ops,
    Module::Neon,
    Module::Fallback
];

const FILE_BASE: &str = "./fearless_simd/src/generated";

fn main() {
    let cli = Cli::parse();
    if let Some(module) = cli.module {
        let code = module.generate_code();
        print_code(&code);
    } else {
        // generate all modules
        let base_dir = Path::new(FILE_BASE);
        if !base_dir.is_dir() {
            panic!("run in fearless_simd top directory");
        }
        for module in MODULES {
            let name = module.file_base();
            let path = base_dir.join(format!("{name}.rs"));
            let mut file = File::create(&path).expect("error creating {path:?}");
            let code_str = module.generate_string();
            file.write_all(code_str.as_bytes())
                .expect("error writing {name}");
        }
    }
}

fn print_code(code: &TokenStream) {
    match syn::parse_file(&code.to_string()) {
        Ok(file) => println!("{}", prettyplease::unparse(&file)),
        Err(e) => {
            println!("error in syn parsing: {e}");
            println!("{code}");
        }
    }
}
